<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeRTOS Tetris: Queue Sets</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom-doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FreeRTOS Tetris
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Queue Sets<div class="ingroups"><a class="el" href="group__freeRTOS.html">FreeRTOS Kernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Group that contains macros &amp; functions for managing queue sets.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Queue Sets:</div>
<div class="dyncontent">
<div class="center"><img src="group__xQueueSet.png" border="0" usemap="#group____xQueueSet" alt=""/></div>
<map name="group____xQueueSet" id="group____xQueueSet">
<area shape="rect" title="Group that contains macros &amp; functions for managing queue sets." alt="" coords="183,5,279,31"/>
<area shape="rect" href="group__freeRTOS.html" title=" " alt="" coords="5,5,135,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad4208ad97f737af942a13e64b45e83e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__QueueHandle.html#ga32a86d604e1706d72a5a4c62d8262f56">QueueSetHandle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xQueueSet.html#gad4208ad97f737af942a13e64b45e83e8">xQueueCreateSet</a> (const <a class="el" href="group__freeRTOSconfig.html#ga646f89d4298e4f5afd522202b11cb2e6">UBaseType_t</a> uxEventQueueLength) PRIVILEGED_FUNCTION</td></tr>
<tr class="separator:gad4208ad97f737af942a13e64b45e83e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae07b563e6bbe42a977f7c46853aa11eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__freeRTOSconfig.html#ga46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xQueueSet.html#gae07b563e6bbe42a977f7c46853aa11eb">xQueueAddToSet</a> (<a class="el" href="group__QueueHandle.html#ga6c19a940d8fe07d338928ecea68b1776">QueueSetMemberHandle_t</a> xQueueOrSemaphore, <a class="el" href="group__QueueHandle.html#ga32a86d604e1706d72a5a4c62d8262f56">QueueSetHandle_t</a> xQueueSet) PRIVILEGED_FUNCTION</td></tr>
<tr class="separator:gae07b563e6bbe42a977f7c46853aa11eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab16fdd17b9b6d74a82c8366f47cda162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__freeRTOSconfig.html#ga46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xQueueSet.html#gab16fdd17b9b6d74a82c8366f47cda162">xQueueRemoveFromSet</a> (<a class="el" href="group__QueueHandle.html#ga6c19a940d8fe07d338928ecea68b1776">QueueSetMemberHandle_t</a> xQueueOrSemaphore, <a class="el" href="group__QueueHandle.html#ga32a86d604e1706d72a5a4c62d8262f56">QueueSetHandle_t</a> xQueueSet) PRIVILEGED_FUNCTION</td></tr>
<tr class="separator:gab16fdd17b9b6d74a82c8366f47cda162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71f56e6277ed4e419c707c8d0c785065"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__QueueHandle.html#ga6c19a940d8fe07d338928ecea68b1776">QueueSetMemberHandle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xQueueSet.html#ga71f56e6277ed4e419c707c8d0c785065">xQueueSelectFromSet</a> (<a class="el" href="group__QueueHandle.html#ga32a86d604e1706d72a5a4c62d8262f56">QueueSetHandle_t</a> xQueueSet, const <a class="el" href="group__freeRTOSconfig.html#gaa69c48c6e902ce54f70886e6573c92a9">TickType_t</a> xTicksToWait) PRIVILEGED_FUNCTION</td></tr>
<tr class="separator:ga71f56e6277ed4e419c707c8d0c785065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac58b34fd733cf460cddab1abb9a899b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__QueueHandle.html#ga6c19a940d8fe07d338928ecea68b1776">QueueSetMemberHandle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__xQueueSet.html#gac58b34fd733cf460cddab1abb9a899b3">xQueueSelectFromSetFromISR</a> (<a class="el" href="group__QueueHandle.html#ga32a86d604e1706d72a5a4c62d8262f56">QueueSetHandle_t</a> xQueueSet) PRIVILEGED_FUNCTION</td></tr>
<tr class="separator:gac58b34fd733cf460cddab1abb9a899b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Group that contains macros &amp; functions for managing queue sets. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae07b563e6bbe42a977f7c46853aa11eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae07b563e6bbe42a977f7c46853aa11eb">&#9670;&nbsp;</a></span>xQueueAddToSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__freeRTOSconfig.html#ga46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> xQueueAddToSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__QueueHandle.html#ga6c19a940d8fe07d338928ecea68b1776">QueueSetMemberHandle_t</a>&#160;</td>
          <td class="paramname"><em>xQueueOrSemaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__QueueHandle.html#ga32a86d604e1706d72a5a4c62d8262f56">QueueSetHandle_t</a>&#160;</td>
          <td class="paramname"><em>xQueueSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;queue.h&gt;</code></p>
<p>Adds a queue or semaphore to a queue set that was previously created by a call to <a class="el" href="group__xQueueSet.html#gad4208ad97f737af942a13e64b45e83e8">xQueueCreateSet()</a>.</p>
<p>See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this function.</p>
<p>Note 1: A receive (in the case of a queue) or take (in the case of a semaphore) operation must not be performed on a member of a queue set unless a call to <a class="el" href="group__xQueueSet.html#ga71f56e6277ed4e419c707c8d0c785065">xQueueSelectFromSet()</a> has first returned a handle to that set member.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xQueueOrSemaphore</td><td>The handle of the queue or semaphore being added to the queue set (cast to an QueueSetMemberHandle_t type).</td></tr>
    <tr><td class="paramname">xQueueSet</td><td>The handle of the queue set to which the queue or semaphore is being added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the queue or semaphore was successfully added to the queue set then pdPASS is returned. If the queue could not be successfully added to the queue set because it is already a member of a different queue set then pdFAIL is returned. </dd></dl>

</div>
</div>
<a id="gad4208ad97f737af942a13e64b45e83e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4208ad97f737af942a13e64b45e83e8">&#9670;&nbsp;</a></span>xQueueCreateSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__QueueHandle.html#ga32a86d604e1706d72a5a4c62d8262f56">QueueSetHandle_t</a> xQueueCreateSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__freeRTOSconfig.html#ga646f89d4298e4f5afd522202b11cb2e6">UBaseType_t</a>&#160;</td>
          <td class="paramname"><em>uxEventQueueLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;queue.h&gt;</code></p>
<p>Queue sets provide a mechanism to allow a task to block (pend) on a read operation from multiple queues or semaphores simultaneously.</p>
<p>See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this function.</p>
<p>A queue set must be explicitly created using a call to <a class="el" href="group__xQueueSet.html#gad4208ad97f737af942a13e64b45e83e8">xQueueCreateSet()</a> before it can be used. Once created, standard FreeRTOS queues and semaphores can be added to the set using calls to <a class="el" href="group__xQueueSet.html#gae07b563e6bbe42a977f7c46853aa11eb">xQueueAddToSet()</a>. <a class="el" href="group__xQueueSet.html#ga71f56e6277ed4e419c707c8d0c785065">xQueueSelectFromSet()</a> is then used to determine which, if any, of the queues or semaphores contained in the set is in a state where a queue read or semaphore take operation would be successful.</p>
<p>Note 1: See the documentation on <a href="http://wwwFreeRTOS.org/RTOS-queue-sets.html">http://wwwFreeRTOS.org/RTOS-queue-sets.html</a> for reasons why queue sets are very rarely needed in practice as there are simpler methods of blocking on multiple objects.</p>
<p>Note 2: Blocking on a queue set that contains a mutex will not cause the mutex holder to inherit the priority of the blocked task.</p>
<p>Note 3: An additional 4 bytes of RAM is required for each space in a every queue added to a queue set. Therefore counting semaphores that have a high maximum count value should not be added to a queue set.</p>
<p>Note 4: A receive (in the case of a queue) or take (in the case of a semaphore) operation must not be performed on a member of a queue set unless a call to <a class="el" href="group__xQueueSet.html#ga71f56e6277ed4e419c707c8d0c785065">xQueueSelectFromSet()</a> has first returned a handle to that set member.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uxEventQueueLength</td><td>Queue sets store events that occur on the queues and semaphores contained in the set. uxEventQueueLength specifies the maximum number of events that can be queued at once. To be absolutely certain that events are not lost uxEventQueueLength should be set to the total sum of the length of the queues added to the set, where binary semaphores and mutexes have a length of 1, and counting semaphores have a length set by their maximum count value. Examples:<ul>
<li>If a queue set is to hold a queue of length 5, another queue of length 12, and a binary semaphore, then uxEventQueueLength should be set to (5 + 12 + 1), or 18.</li>
<li>If a queue set is to hold three binary semaphores then uxEventQueueLength should be set to (1 + 1 + 1 ), or 3.</li>
<li>If a queue set is to hold a counting semaphore that has a maximum count of 5, and a counting semaphore that has a maximum count of 3, then uxEventQueueLength should be set to (5 + 3), or 8.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the queue set is created successfully then a handle to the created queue set is returned. Otherwise NULL is returned. </dd></dl>

</div>
</div>
<a id="gab16fdd17b9b6d74a82c8366f47cda162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab16fdd17b9b6d74a82c8366f47cda162">&#9670;&nbsp;</a></span>xQueueRemoveFromSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__freeRTOSconfig.html#ga46fb21e00ae0729d7515c0fbf2269796">BaseType_t</a> xQueueRemoveFromSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__QueueHandle.html#ga6c19a940d8fe07d338928ecea68b1776">QueueSetMemberHandle_t</a>&#160;</td>
          <td class="paramname"><em>xQueueOrSemaphore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__QueueHandle.html#ga32a86d604e1706d72a5a4c62d8262f56">QueueSetHandle_t</a>&#160;</td>
          <td class="paramname"><em>xQueueSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;queue.h&gt;</code></p>
<p>Removes a queue or semaphore from a queue set. A queue or semaphore can only be removed from a set if the queue or semaphore is empty.</p>
<p>See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xQueueOrSemaphore</td><td>The handle of the queue or semaphore being removed from the queue set (cast to an QueueSetMemberHandle_t type).</td></tr>
    <tr><td class="paramname">xQueueSet</td><td>The handle of the queue set in which the queue or semaphore is included.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the queue or semaphore was successfully removed from the queue set then pdPASS is returned. If the queue was not in the queue set, or the queue (or semaphore) was not empty, then pdFAIL is returned. </dd></dl>

</div>
</div>
<a id="ga71f56e6277ed4e419c707c8d0c785065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71f56e6277ed4e419c707c8d0c785065">&#9670;&nbsp;</a></span>xQueueSelectFromSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__QueueHandle.html#ga6c19a940d8fe07d338928ecea68b1776">QueueSetMemberHandle_t</a> xQueueSelectFromSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__QueueHandle.html#ga32a86d604e1706d72a5a4c62d8262f56">QueueSetHandle_t</a>&#160;</td>
          <td class="paramname"><em>xQueueSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__freeRTOSconfig.html#gaa69c48c6e902ce54f70886e6573c92a9">TickType_t</a>&#160;</td>
          <td class="paramname"><em>xTicksToWait</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;queue.h&gt;</code></p>
<p><a class="el" href="group__xQueueSet.html#ga71f56e6277ed4e419c707c8d0c785065">xQueueSelectFromSet()</a> selects from the members of a queue set a queue or semaphore that either contains data (in the case of a queue) or is available to take (in the case of a semaphore). <a class="el" href="group__xQueueSet.html#ga71f56e6277ed4e419c707c8d0c785065">xQueueSelectFromSet()</a> effectively allows a task to block (pend) on a read operation on all the queues and semaphores in a queue set simultaneously.</p>
<p>See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this function.</p>
<p>Note 1: See the documentation on <a href="http://wwwFreeRTOS.org/RTOS-queue-sets.html">http://wwwFreeRTOS.org/RTOS-queue-sets.html</a> for reasons why queue sets are very rarely needed in practice as there are simpler methods of blocking on multiple objects.</p>
<p>Note 2: Blocking on a queue set that contains a mutex will not cause the mutex holder to inherit the priority of the blocked task.</p>
<p>Note 3: A receive (in the case of a queue) or take (in the case of a semaphore) operation must not be performed on a member of a queue set unless a call to <a class="el" href="group__xQueueSet.html#ga71f56e6277ed4e419c707c8d0c785065">xQueueSelectFromSet()</a> has first returned a handle to that set member.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xQueueSet</td><td>The queue set on which the task will (potentially) block.</td></tr>
    <tr><td class="paramname">xTicksToWait</td><td>The maximum time, in ticks, that the calling task will remain in the Blocked state (with other tasks executing) to wait for a member of the queue set to be ready for a successful queue read or semaphore take operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__xQueueSet.html#ga71f56e6277ed4e419c707c8d0c785065">xQueueSelectFromSet()</a> will return the handle of a queue (cast to a QueueSetMemberHandle_t type) contained in the queue set that contains data, or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained in the queue set that is available, or NULL if no such queue or semaphore exists before before the specified block time expires. </dd></dl>

</div>
</div>
<a id="gac58b34fd733cf460cddab1abb9a899b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac58b34fd733cf460cddab1abb9a899b3">&#9670;&nbsp;</a></span>xQueueSelectFromSetFromISR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__QueueHandle.html#ga6c19a940d8fe07d338928ecea68b1776">QueueSetMemberHandle_t</a> xQueueSelectFromSetFromISR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__QueueHandle.html#ga32a86d604e1706d72a5a4c62d8262f56">QueueSetHandle_t</a>&#160;</td>
          <td class="paramname"><em>xQueueSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;queue.h&gt;</code></p>
<p>A version of <a class="el" href="group__xQueueSet.html#ga71f56e6277ed4e419c707c8d0c785065">xQueueSelectFromSet()</a> that can be used from an ISR. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
